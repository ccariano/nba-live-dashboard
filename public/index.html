<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>NBA Live Totals</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { background:#0f1115; color:#eaeef4; font:14px system-ui,-apple-system,Segoe UI,Roboto; margin:0 }
    header { display:flex; gap:12px; align-items:center; padding:12px 16px; border-bottom:1px solid #222 }
    input, select, button { background:#161a22; color:#eaeef4; border:1px solid #2a2f3a; border-radius:6px; padding:6px 8px }
    button { cursor:pointer }
    #lastFetch { opacity:.7 }
    main { padding:12px 16px }
    table { width:100%; border-collapse:collapse; font-size:13px }
    th, td { padding:8px 10px; border-bottom:1px solid #1c2030; text-align:left; white-space:nowrap }
    thead th { position:sticky; top:0; background:#111419; z-index:1 }
    tr:hover { background:#121622 }
    tr.selected { outline:2px solid #2a7cf7 }
    .hi { color:#18c26e; font-weight:600 }
    .lo { color:#ff6b6b; font-weight:600 }
    #chartWrap { height:340px; margin-top:12px; background:#0d1016; border:1px solid #1c2030; border-radius:8px; padding:8px }
    #error { display:none; margin:8px 0; padding:8px; border:1px solid #a33; background:#2a1111; color:#f7c6c6 }
    .spacer { flex:1 }
    label.chk { display:inline-flex; gap:6px; align-items:center }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1"></script>
</head>
<body>
  <header>
    <label class="chk"><input type="checkbox" id="liveToggle" checked> Live</label>
    <label class="chk"><input type="checkbox" id="todayOnly" checked> Today only</label>
    <select id="bookmaker">
      <option value="draftkings" selected>DraftKings</option>
      <option value="fanduel">FanDuel</option>
      <option value="caesars">Caesars</option>
    </select>
    <input id="search" placeholder="Filter by team name">
    <button id="refresh">Refresh now</button>
    <div id="lastFetch"></div>
    <div class="spacer"></div>
    <label class="chk"><input type="checkbox" id="showLive" checked> Show Live Total</label>
    <label class="chk"><input type="checkbox" id="showProj" checked> Show Projection</label>
    <input id="gapThres" type="number" value="5" style="width:64px" title="Alert gap ≥">
  </header>

  <main>
    <div id="error"></div>
    <div style="overflow:auto; border:1px solid #1c2030; border-radius:8px;">
      <table id="gamesTable">
        <thead>
          <tr>
            <th>Away Team</th>
            <th>Away Score</th>
            <th>Home Team</th>
            <th>Home Score</th>
            <th>Current Total</th>
            <th>Quarter</th>
            <th>Clock</th>
            <th>Projection</th>
            <th>Live Total</th>
            <th>Pace %</th>
            <th>Δ5m</th>
            <th>Gap</th>
            <th>Tipoff</th>
            <th>Last Update</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div id="chartWrap">
      <canvas id="chart"></canvas>
    </div>
  </main>

<script>
  const REFRESH_MS = 60000
  const MAX_POINTS = 300

  const state = {
    history: new Map(),  // id -> { label, live:[], proj:[], score:[] }
    chart: null,
    selectedGameId: null,
    lastRows: [],
    filteredRows: [],
    scoreMap: new Map()
  }

  function gameLabel(row) { return `${row.away_team} @ ${row.home_team}` }

  function isTodayLocal(iso) {
    if (!iso) return false
    const d = new Date(iso)
    const now = new Date()
    return d.getFullYear() === now.getFullYear() &&
           d.getMonth() === now.getMonth() &&
           d.getDate() === now.getDate()
  }

  function minutesElapsed(period, clock) {
    if (!period) return null
    if (clock && /^\d{1,2}:\d{2}$/.test(clock)) {
      const [mm, ss] = clock.split(":").map(Number)
      const perLen = period <= 4 ? 12 : 5
      const elapsedInPeriod = perLen - mm - ss/60
      if (period <= 4) return (period - 1) * 12 + Math.max(0, elapsedInPeriod)
      const otNum = period - 4
      return 48 + (otNum - 1) * 5 + Math.max(0, elapsedInPeriod)
    }
    if (period >= 4) return 36
    if (period === 3) return 24
    if (period === 2) return 12
    if (period === 1) return 0
    return null
  }
  function totalMinutes(period) { return period <= 4 ? 48 : 48 + 5*(period-4) }

  function paceProjection(home, away, period, clock) {
    if (home == null || away == null || period == null) return null
    const elapsed = minutesElapsed(period, clock)
    if (elapsed == null || elapsed <= 0) return null
    const total = totalMinutes(period)
    const current = Number(home) + Number(away)
    const frac = Math.max(elapsed / total, 0.01)
    return Math.round((current / frac) * 10) / 10
  }

  function pacePercent(currentTotal, liveTotal, period, clock) {
    if (currentTotal == null || liveTotal == null || period == null) return null
    const elapsed = minutesElapsed(period, clock)
    const total = totalMinutes(period)
    if (elapsed == null || elapsed <= 0) return null
    const expectedSoFarAtLine = liveTotal * (elapsed / total)
    if (expectedSoFarAtLine <= 0) return null
    return Math.round((currentTotal / expectedSoFarAtLine) * 1000) / 10
  }

  function delta5m(gameId) {
    const s = state.history.get(gameId)
    if (!s || !s.live?.length) return null
    const now = Date.now()
    const cutoff = now - 5*60*1000
    let oldest = null
    for (let i = s.live.length - 1; i >= 0; i--) {
      const p = s.live[i]
      if (p.x <= cutoff) { oldest = p; break }
    }
    if (!oldest) oldest = s.live[0]
    const latest = s.live[s.live.length - 1]
    if (!latest || oldest.y == null || latest.y == null) return null
    return Math.round((latest.y - oldest.y) * 10) / 10
  }

  function upsertHistory(rows, scoreMap) {
    const now = Date.now()
    for (const r of rows) {
      const key = r.id
      if (!state.history.has(key)) state.history.set(key, { label: gameLabel(r), live: [], proj: [], score: [] })
      const serie = state.history.get(key)
      if (typeof r.total_point === "number") {
        serie.live.push({ x: now, y: r.total_point })
        if (serie.live.length > MAX_POINTS) serie.live.shift()
      }
      const sKey = `${r.away_team}__${r.home_team}`.toLowerCase()
      const sc = scoreMap.get(sKey) || {}
      const p = paceProjection(sc.home_score, sc.away_score, sc.period, sc.clock)
      if (typeof p === "number") {
        serie.proj.push({ x: now, y: p })
        if (serie.proj.length > MAX_POINTS) serie.proj.shift()
      }
      if (sc.home_score != null && sc.away_score != null) {
        const total = Number(sc.home_score) + Number(sc.away_score)
        serie.score.push({ x: now, y: total })
        if (serie.score.length > MAX_POINTS) serie.score.shift()
      }
      serie.label = gameLabel(r)
    }
  }

  function metricsForRow(r, sc) {
    const projection = paceProjection(sc.home_score, sc.away_score, sc.period, sc.clock)
    const currentTotal = (sc.home_score != null && sc.away_score != null) ? (Number(sc.home_score) + Number(sc.away_score)) : null
    const gap = (projection != null && typeof r.total_point === "number") ? Math.round((projection - r.total_point) * 10) / 10 : null
    const pace = pacePercent(currentTotal, r.total_point, sc.period, sc.clock)
    const d5 = delta5m(r.id)
    return { projection, currentTotal, gap, pace, d5 }
  }

  function renderTable(rows) {
    const q = document.getElementById("search").value.toLowerCase().trim()
    const gapThres = Number(document.getElementById("gapThres").value) || 5
    const todayOnly = document.getElementById("todayOnly").checked

    const tbody = document.querySelector("#gamesTable tbody")
    tbody.innerHTML = ""

    let filtered = rows
    if (todayOnly) filtered = filtered.filter(r => isTodayLocal(r.commence_time))
    filtered = filtered.filter(r => {
      const s = `${r.home_team} ${r.away_team}`.toLowerCase()
      return !q || s.includes(q)
    })

    state.filteredRows = filtered

    if (filtered.length === 1) state.selectedGameId = filtered[0].id
    else if (!state.selectedGameId || !filtered.find(r => r.id === state.selectedGameId)) state.selectedGameId = null

    for (const r of filtered) {
      const sKey = `${r.away_team}__${r.home_team}`.toLowerCase()
      const sc = state.scoreMap.get(sKey) || {}
      const { projection, currentTotal, gap, pace, d5 } = metricsForRow(r, sc)

      const tr = document.createElement("tr")
      tr.dataset.id = r.id
      if (state.selectedGameId === r.id) tr.classList.add("selected")
      tr.addEventListener("click", () => {
        state.selectedGameId = state.selectedGameId === r.id ? null : r.id
        renderChart()
        renderTable(state.lastRows)
      })

      const cells = [
        r.away_team,
        sc.away_score ?? "n/a",
        r.home_team,
        sc.home_score ?? "n/a",
        currentTotal ?? "n/a",
        sc.period ?? "n/a",
        sc.clock ?? "n/a",
        projection ?? "n/a",
        r.total_point ?? "n/a",
        pace != null ? `${pace}%` : "n/a",
        d5 != null ? d5.toFixed(1) : "n/a",
        gap ?? "n/a",
        r.commence_time ? new Date(r.commence_time).toLocaleString() : "n/a",
        r.bookmaker_last_update ? new Date(r.bookmaker_last_update).toLocaleTimeString() : "n/a"
      ]

      cells.forEach((val, idx) => {
        const td = document.createElement("td")
        td.textContent = val
        if (idx === 10 && typeof d5 === "number") td.className = d5 >= 2 ? "hi" : d5 <= -2 ? "lo" : ""
        if (idx === 9 && typeof pace === "number") td.className = pace >= 105 ? "hi" : pace <= 95 ? "lo" : ""
        if (idx === 11 && typeof gap === "number") td.className = Math.abs(gap) >= gapThres ? (gap > 0 ? "hi" : "lo") : ""
        tr.appendChild(td)
      })

      if (pace != null && gap != null && d5 != null) {
        if (pace >= 105 && gap >= 5 && d5 >= 2) tr.classList.add("selected")
      }

      tbody.appendChild(tr)
    }
  }

  function color(i, n) {
    const h = Math.floor((360 * i) / Math.max(1, n))
    return `hsl(${h},70%,55%)`
  }

  function renderChart() {
    const ctx = document.getElementById("chart").getContext("2d")
    let series = Array.from(state.history.entries()).map(([id, s]) => ({ id, ...s }))

    const todayOnly = document.getElementById("todayOnly").checked
    const q = document.getElementById("search").value.toLowerCase().trim()

    let currentRows = state.lastRows
    if (todayOnly) currentRows = currentRows.filter(r => isTodayLocal(r.commence_time))
    if (q) currentRows = currentRows.filter(r => (`${r.home_team} ${r.away_team}`).toLowerCase().includes(q))

    if (state.selectedGameId) series = series.filter(s => s.id === state.selectedGameId)
    else if (currentRows.length === 1) series = series.filter(s => s.id === currentRows[0].id)
    else {
      const ids = new Set(currentRows.map(r => r.id))
      series = series.filter(s => ids.has(s.id))
    }

    const showLive = document.getElementById("showLive").checked
    const showProj = document.getElementById("showProj").checked

    const datasets = []
    series.forEach((s, i) => {
      if (showLive) {
        datasets.push({
          label: `${s.label} • Live`,
          data: s.live,
          tension: 0.25,
          borderWidth: 2,
          borderColor: color(i, series.length),
          pointRadius: 0,
          fill: false
        })
      }
      if (showProj) {
        datasets.push({
          label: `${s.label} • Proj`,
          data: s.proj,
          tension: 0.25,
          borderWidth: 2,
          borderDash: [6,3],
          borderColor: color(i+1, series.length+1),
          pointRadius: 0,
          fill: false
        })
      }
    })

    if (!state.chart) {
      state.chart = new Chart(ctx, {
        type: "line",
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          interaction: { mode: "nearest", intersect: false },
          scales: {
            x: { type: "time", time: { unit: "minute" } },
            y: { title: { display: true, text: "Total" } }
          },
          plugins: { legend: { position: "bottom" }, tooltip: { enabled: true } }
        }
      })
    } else {
      state.chart.data.datasets = datasets
      state.chart.update()
    }
  }

  async function seedHistory() {
    try {
      const r = await fetch("/api/history")
      if (!r.ok) return
      const h = await r.json()
      for (const [id, points] of Object.entries(h)) {
        if (!state.history.has(id)) state.history.set(id, { label: "", live: [], proj: [], score: [] })
        const serie = state.history.get(id)
        serie.live = points.map(p => ({ x: p.ts, y: p.y }))
      }
    } catch {}
  }

  async function fetchAll() {
    const live = document.getElementById("liveToggle").checked
    const bookmaker = document.getElementById("bookmaker").value
    const banner = document.getElementById("error")
    banner.style.display = "none"
    try {
      const [oddsRes, scoresRes] = await Promise.all([
        fetch(`/api/odds?live=${live ? "true" : "false"}&bookmaker=${encodeURIComponent(bookmaker)}`),
        fetch(`/api/scores`)
      ])
      if (!oddsRes.ok) throw new Error(await oddsRes.text() || `HTTP ${oddsRes.status}`)
      if (!scoresRes.ok) throw new Error(await scoresRes.text() || `HTTP ${scoresRes.status}`)
      const rows = await oddsRes.json()
      const scores = await scoresRes.json()
      state.lastRows = rows
      state.scoreMap = new Map(
        scores.map(s => [`${(s.away_team||'').toLowerCase()}__${(s.home_team||'').toLowerCase()}`, s])
      )
      // label refresh and projections update
      for (const r of rows) {
        const key = r.id
        if (!state.history.has(key)) state.history.set(key, { label: "", live: [], proj: [], score: [] })
        state.history.get(key).label = `${r.away_team} @ ${r.home_team}`
      }
      upsertHistory(rows, state.scoreMap)
      renderTable(rows)
      renderChart()
      document.getElementById("lastFetch").textContent = `Last refresh ${new Date().toLocaleTimeString()}`
    } catch (e) {
      banner.textContent = `Error: ${e.message.slice(0, 200)}`
      banner.style.display = "block"
    }
  }

  document.getElementById("refresh").addEventListener("click", fetchAll)
  for (const id of ["search","todayOnly","gapThres","showLive","showProj"]) {
    const el = document.getElementById(id)
    if (!el) continue
    el.addEventListener("input", () => { renderTable(state.lastRows); renderChart() })
    el.addEventListener("change", () => { renderTable(state.lastRows); renderChart() })
  }
  document.getElementById("liveToggle").addEventListener("change", fetchAll)

  ;(async () => {
    await seedHistory()
    await fetchAll()
    setInterval(fetchAll, REFRESH_MS)
  })()
</script>
</body>
</html>
